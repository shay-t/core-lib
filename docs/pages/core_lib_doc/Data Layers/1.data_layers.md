---
id: data_layers
title: Data Layers
sidebar: core_lib_doc_sidebar
permalink: data_layers.html
folder: core_lib_doc
toc: false
---

`Core-Lib` embraces the `Onion Architecture` [1](https://www.codeguru.com/csharp/csharp/cs_misc/designtechniques/understanding-onion-architecture.html) [2](https://www.google.com/search?sxsrf=ACYBGNT0NhYbUZLnDQbC9b6uPBqjZmjwgw%3A1579104811273&ei=KzofXuOfEO3IgwfngLPwAg&q=onion+Architecture&oq=onion+Architecture&gs_l=psy-ab.12...0.0..109691...0.0..0.0.0.......0......gws-wiz.oEYi3afxy_c&ved=0ahUKEwij4drq_4XnAhVt5OAKHWfADC4Q4dUDCAs)  for code reuse and data flow across libraries. Reusing code and moving logic from one `Data-Layer` to another is straightforward.



## The Data Layers

1. `Data` Layer
2. `Data Access` Layer
3. `Service` Layer



## `Data` Layer

The `Data` layer defines low-level assets that are used to connect to various third-party sources. For example connection, entities, migration, mapping, etc.. 

#### Responsibilities: 

- Define models/entities/connection/migration used by data source

#### Example define a database entity under the DB connection

##### <project_dir>/data_layers/data/db/user.py

```python
from core_lib.data_layers.data.db.sqlalchemy.base import Base
from core_lib.data_layers.data.db.sqlalchemy.mixins.soft_delete_mixin import SoftDeleteMixin
from sqlalchemy import Column, Integer, VARCHAR


class User(SoftDeleteMixin, Base):
    __tablename__ = 'user'

    id = Column(Integer, primary_key=True, nullable=False)
    email = Column(VARCHAR(length=255), nullable=False)
    ...
```

#### Code Explained:
- <b>Imports:</b>
    - Base: This is typically a SQLAlchemy declarative base class. It's a base class for all your model classes.
    - SoftDeleteMixin: This is a custom mixin that adds soft delete functionality to your model, meaning instead of physically deleting records from the database, it marks them as deleted.
    - Column, Integer, VARCHAR: These are classes and types provided by SQLAlchemy for defining columns in your database tables.
- <b>Class Definition:</b>
    - User: This is the model class being defined.
    - SoftDeleteMixin, Base: The class inherits from SoftDeleteMixin and Base. By placing SoftDeleteMixin before Base in the inheritance list, you ensure that methods from SoftDeleteMixin take precedence in case of conflicts.
- <b>Table Configuration:</b>
    - __tablename__: This specifies the name of the database table associated with this model. In this case, it's set to 'user'.
- <b>Columns:</b>
    - id: This is a primary key column of type Integer, meaning it holds integer values and uniquely identifies each record in the table.
    - email: This is a column of type VARCHAR, which is a variable-length string type, with a maximum length of 255 characters. It stores the email address of the user.

## `Data Access` Layer

Encapsulate and expose access methods to the `Data` layer.

#### Responsibilities: 

- Define `APIs` to access the `Data` Layer.
- Optimization and speed of data fetching.
- Validate the data when creating records.

```python
class UserDataAccess(DataAccess):

    def __init__(self, db_session: SqlAlchemyConnectionRegistry):
        self.db_session = db_session

    def get(self, id: int):
        with self.db_session.get() as session:
            return session.Query(User).get(id)
```
#### Code Explained:
- <b>Class Definition:</b>
    - UserDataAccess: This is the class being defined.
- <b>Constructor:</b>
    - def __init__(self, db_session: SqlAlchemyConnectionRegistry): This is the constructor method. It initializes instances of UserDataAccess. It takes a parameter db_session of type SqlAlchemyConnectionRegistry, which presumably provides access to the database session.
- <b>Attributes:</b>
    - self.db_session: This attribute stores the reference to the database session provided during initialization. It's used to interact with the database.
- <b>Methods:</b>
    - def get(self, id: int): This method fetches a user from the database based on the provided id.
        - It first opens a session using self.db_session.get(), which presumably provides a context manager for accessing the database session.
        - Inside the context manager, it queries the database using `session.Query(User).get(id)`. This should fetch a user with the specified `id` from the `User` table. However, there's a typo: it should be `session.query(User).get(id)` instead of `session.Query(User).get(id)`.


## `Service` Layer

The `Service` layer provides an API that its users can access.  And it will use  `DataLayer`/Other `Services`/`Connection` to do so. 

#### Responsibilities: 

- Business Logic

- Transform return data to `dict`

- Caching

```python
from core_lib.data_transform.result_to_dict import ResultToDict
from core_lib.data_layers.service.service import Service

CACHE_KEY_USER = 'key_user_{user_id}'


class UserService(Service):

    def __init__(self, user_data_access: UserDataAccess, user_friends_data_acccess: UserFriendsDataAccess):
        self.user_data_access = user_data_access
        self.user_friends_data_acccess = user_friends_data_acccess

    @Cache(CACHE_KEY_USER)
    @ResultToDict() 
    def get(self, user_id: int):
        user = self.user_data_access.get(user_id)
        if user.something:
            user.friends = self.user_friends_data_acccess.get_user_friends(user_id)
        return user
```
#### Code Explained:
- <b>Imports:</b>
    - ResultToDict: This appears to be a decorator or a function imported from core_lib.data_transform.result_to_dict. It possibly converts query results into a dictionary format.
    - Service: This likely represents a base class for services.
- <b>Constants:</b>
    - CACHE_KEY_USER: This defines a constant string representing the cache key format for user-related data.
- <b>Class Definition:</b>
    - UserService: This is the class being defined. It presumably provides services related to users.
- <b>Constructor:</b>
    - def __init__(self, user_data_access: UserDataAccess, user_friends_data_acccess: UserFriendsDataAccess): This is the constructor method. It initializes instances of UserService. It takes two parameters:
        - user_data_access: An instance of UserDataAccess, presumably responsible for accessing user data.
        - user_friends_data_acccess: An instance of UserFriendsDataAccess, presumably responsible for accessing user friends data.
- <b>Attributes:</b>
    - self.user_data_access: This attribute stores the instance of UserDataAccess.
    - self.user_friends_data_acccess: This attribute stores the instance of UserFriendsDataAccess.
- <b>Methods:</b>
    - def get(self, user_id: int): This method retrieves user data for the given user_id.
    - It decorates the method with @Cache(CACHE_KEY_USER), suggesting caching of the results based on some cache key format.
    - It also decorates the method with @ResultToDict(), possibly to transform the result into a dictionary format.
    - It retrieves user data using self.user_data_access.get(user_id).
    - If there's some condition like if user.something, it suggests additional logic based on some attribute something of the user object.
    - It fetches user friends data using self.user_friends_data_acccess.get_user_friends(user_id).
    - Finally, it returns the user data, possibly augmented with friends data.